@page "/"
@using NPOI.Util;
@using NPOI.XWPF.UserModel;
@using PDFTemplateGenerator; // Use the correct namespace where DocxFromTemplate is defined

@inject PDFTemplateGenerator.Services.ExcelMergeService excelMerge;
@inject PDFTemplateGenerator.Services.WordMergeServiceNPOI wordMerge;

@using Microsoft.Maui.ApplicationModel
@using Microsoft.Maui.Storage

<h1>Hello, world!</h1>

Welcome to your new app.


<h3>Build Excel from Template</h3>

<div class="buttons">
    <button class="btn btn-primary" @onclick="FillPlaceholders">Fill placeholders (first CSV row)</button>
    <button class="btn btn-secondary" @onclick="AppendTable">Append table (all CSV rows)</button>
</div>

<h3>Build DOCX from Template</h3>

<div class="buttons">
    <button class="btn btn-primary" @onclick="FillPlaceholdersDOCX">Fill placeholders (first CSV row)</button>
    <button class="btn btn-secondary" @onclick="BuildTable">Append table (all CSV rows)</button>
</div>

@if (!string.IsNullOrWhiteSpace(_status))
{
    <p>@_status</p>
    @if (!string.IsNullOrWhiteSpace(_lastOutputPath))
    {
        <p><code>@_lastOutputPath</code></p>
        <button class="btn btn-link" @onclick="OpenOutput">Open file</button>
        <button class="btn btn-link" @onclick="ShareOutput">Share file</button>
    }
}


@code {

    private void GenerateBuyersGuide()
    {
        var data = new Dictionary<string, string>
        {

            ["{{Make}}"] = "Atun",
            ["{{Model}}"] = "Bey",
            ["{{Year}}"] = "123 Main St",
            ["{{VIN}}"] = "Columbia",
            ["{{Trim}}"] = "SC",
            ["{{Stock_No}}"] = "29201"

        };
        // Logic to generate PDF template using the data dictionary
        // This is a placeholder for actual PDF generation code

        //DocxFromTemplate.Generate("template.docx", "letter-out.docx", data);
        Console.WriteLine("Generating PDF Template with the following data:");
        foreach (var item in data)
        {
            Console.WriteLine($"{item.Key}: {item.Value}");
        }
    }

    private void GenerateVEL()
    {
        
    }


    private string? _status;
    private string? _lastOutputPath;

    private async Task FillPlaceholders()
    {
        try
        {
            _status = "Working...";
            StateHasChanged();

            _lastOutputPath = await excelMerge.FillTemplateFromCsvAsync(
                templateAssetFileName: "Template.xlsx",
                csvAssetFileName: "Data.csv",
                outputFileName: "Output_Filled.xlsx");

            _status = $"Created: {_lastOutputPath}";
        }
        catch (Exception ex)
        {
            _status = "Error: " + ex.Message;
            _lastOutputPath = null;
        }
        finally
        {
            StateHasChanged();
        }
    }

    private async Task AppendTable()
    {
        try
        {
            _status = "Working...";
            StateHasChanged();

            _lastOutputPath = await excelMerge.AppendTableFromCsvAsync(
                templateAssetFileName: "Template.xlsx",
                csvAssetFileName: "Data.csv",
                outputFileName: "Output_Table.xlsx",
                sheetName: "Report", // change if your template uses a different sheet
                headerRowIdx: 0);

            _status = $"Created: {_lastOutputPath}";
        }
        catch (Exception ex)
        {
            _status = "Error: " + ex.Message;
            _lastOutputPath = null;
        }
        finally
        {
            StateHasChanged();
        }
    }

    private async Task OpenOutput()
    {
        if (string.IsNullOrEmpty(_lastOutputPath)) return;

        // Attempts to open using the platform's default app
        await Launcher.Default.OpenAsync(new OpenFileRequest
        {
            File = new ReadOnlyFile(_lastOutputPath)
        });
    }

    private async Task ShareOutput()
    {
        if (string.IsNullOrEmpty(_lastOutputPath)) return;

        await Share.Default.RequestAsync(new ShareFileRequest
        {
            Title = "Generated Excel",
            File = new ShareFile(_lastOutputPath, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
        });
    }


    private async Task FillPlaceholdersDOCX()
    {
        try
        {
            _status = "Working...";
            StateHasChanged();

            _lastOutputPath = await wordMerge.FillDocxPlaceholdersFromCsvAsync(
                templateAsset: "Parker_MailMerge_VEL.docx",
                csvAsset: "ParkerExport20251113_brand_specific_warranty.csv",
                outputFileName: "ParkerVEL20251119_Filled.docx");

            _status = $"Created: {_lastOutputPath}";
        }
        catch (Exception ex)
        {
            _status = "Error: " + ex.Message;
            _lastOutputPath = null;
        }
        finally { StateHasChanged(); }
    }

    private async Task BuildTable()
    {
        try
        {
            _status = "Working...";
            StateHasChanged();

            _lastOutputPath = await wordMerge.FillDocxTableFromCsvAsync(
                templateAsset: "Parker_MailMerge_VEL.docx",
                csvAsset: "ParkerExport20251113_brand_specific_warranty.csv",
                outputFileName: "ParkerVEL20251121_All.docx",
                matchTableByHeader: true);

            _status = $"Created: {_lastOutputPath}";
        }
        catch (Exception ex)
        {
            _status = "Error: " + ex.Message;
            _lastOutputPath = null;
        }
        finally { StateHasChanged(); }
    }

    private async Task OpenOutputDOCX()
    {
        if (string.IsNullOrWhiteSpace(_lastOutputPath)) return;
        await Launcher.Default.OpenAsync(new OpenFileRequest
        {
            File = new ReadOnlyFile(_lastOutputPath)
        });
    }

    private async Task ShareOutputDOCX()
    {
        if (string.IsNullOrWhiteSpace(_lastOutputPath)) return;
        await Share.Default.RequestAsync(new ShareFileRequest
        {
            Title = "Generated DOCX (NPOI)",
            File = new ShareFile(_lastOutputPath, "application/vnd.openxmlformats-officedocument.wordprocessingml.document")
        });
    }


}
